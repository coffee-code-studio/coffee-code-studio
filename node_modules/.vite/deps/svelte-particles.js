import {
  tsParticles
} from "./chunk-PRHUGDEN.js";
import "./chunk-3A7IXJCA.js";
import {
  SvelteComponentDev,
  add_location,
  afterUpdate,
  attr_dev,
  children,
  claim_element,
  createEventDispatcher,
  detach_dev,
  dispatch_dev,
  element,
  flush,
  globals,
  init,
  insert_hydration_dev,
  noop,
  safe_not_equal,
  validate_slots
} from "./chunk-3FFRLI4B.js";

// node_modules/.pnpm/svelte-particles@2.8.0_svelte@3.55.1/node_modules/svelte-particles/src/Particles.svelte
var { console: console_1 } = globals;
var file = "node_modules/.pnpm/svelte-particles@2.8.0_svelte@3.55.1/node_modules/svelte-particles/src/Particles.svelte";
function create_fragment(ctx) {
  let div;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { id: true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        div,
        "id",
        /*id*/
        ctx[0]
      );
      add_location(div, file, 47, 0, 1185);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*id*/
      1) {
        attr_dev(
          div,
          "id",
          /*id*/
          ctx2[0]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var particlesLoadedEvent = "particlesLoaded";
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Particles", slots, []);
  let { options = {} } = $$props;
  let { url = "" } = $$props;
  let { id = "tsparticles" } = $$props;
  let { particlesInit } = $$props;
  const dispatch = createEventDispatcher();
  let oldId = id;
  afterUpdate(async () => {
    tsParticles.init();
    if (particlesInit) {
      await particlesInit(tsParticles);
    }
    if (oldId) {
      const oldContainer = tsParticles.dom().find((c) => c.id === oldId);
      if (oldContainer) {
        oldContainer.destroy();
      }
    }
    if (id) {
      const cb = (container2) => {
        dispatch(particlesLoadedEvent, { particles: container2 });
        oldId = id;
      };
      let container;
      if (url) {
        container = await tsParticles.loadJSON(id, url);
      } else if (options) {
        container = await tsParticles.load(id, options);
      } else {
        console.error("You must specify options or url to load tsParticles");
        return;
      }
      cb(container);
    } else {
      dispatch(particlesLoadedEvent, { particles: void 0 });
    }
  });
  $$self.$$.on_mount.push(function() {
    if (particlesInit === void 0 && !("particlesInit" in $$props || $$self.$$.bound[$$self.$$.props["particlesInit"]])) {
      console_1.warn("<Particles> was created without expected prop 'particlesInit'");
    }
  });
  const writable_props = ["options", "url", "id", "particlesInit"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console_1.warn(`<Particles> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("options" in $$props2)
      $$invalidate(1, options = $$props2.options);
    if ("url" in $$props2)
      $$invalidate(2, url = $$props2.url);
    if ("id" in $$props2)
      $$invalidate(0, id = $$props2.id);
    if ("particlesInit" in $$props2)
      $$invalidate(3, particlesInit = $$props2.particlesInit);
  };
  $$self.$capture_state = () => ({
    afterUpdate,
    createEventDispatcher,
    tsParticles,
    options,
    url,
    id,
    particlesInit,
    dispatch,
    particlesLoadedEvent,
    oldId
  });
  $$self.$inject_state = ($$props2) => {
    if ("options" in $$props2)
      $$invalidate(1, options = $$props2.options);
    if ("url" in $$props2)
      $$invalidate(2, url = $$props2.url);
    if ("id" in $$props2)
      $$invalidate(0, id = $$props2.id);
    if ("particlesInit" in $$props2)
      $$invalidate(3, particlesInit = $$props2.particlesInit);
    if ("oldId" in $$props2)
      oldId = $$props2.oldId;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [id, options, url, particlesInit];
}
var Particles = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {
      options: 1,
      url: 2,
      id: 0,
      particlesInit: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Particles",
      options,
      id: create_fragment.name
    });
  }
  get options() {
    return this.$$.ctx[1];
  }
  set options(options) {
    this.$$set({ options });
    flush();
  }
  get url() {
    return this.$$.ctx[2];
  }
  set url(url) {
    this.$$set({ url });
    flush();
  }
  get id() {
    return this.$$.ctx[0];
  }
  set id(id) {
    this.$$set({ id });
    flush();
  }
  get particlesInit() {
    return this.$$.ctx[3];
  }
  set particlesInit(particlesInit) {
    this.$$set({ particlesInit });
    flush();
  }
};
var Particles_default = Particles;
export {
  Particles_default as default
};
//# sourceMappingURL=svelte-particles.js.map
